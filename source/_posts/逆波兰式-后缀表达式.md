---
title: 逆波兰式/后缀表达式
tags: []
id: '297'
categories: 数据结构与算法
date: 2020-03-24 21:08:08
---

![](http://www.zhaoxuanlang.cn/wp-content/uploads/2020/03/image-5.png)

下面以(a+b)\*c为例子进行说明：(a+b)\*c的逆波兰式为ab+c\*，假设计算机把ab+c\*按从左到右的顺序压入栈中，并且按照遇到[运算符](https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6)就把栈顶两个元素[出栈](https://baike.baidu.com/item/%E5%87%BA%E6%A0%88)，执行运算，得到的结果再入栈的原则来进行处理，那么ab+c\*的执行结果如下：1）a入栈（0位置）2）b入栈（1位置）3）遇到运算符“+”，将a和b出栈，执行a+b的操作，得到结果d=a+b，再将d入栈（0位置）4）c入栈（1位置）5）遇到运算符“\*”，将d和c出栈，执行d\*c的操作，得到结果e，再将e入栈（0位置）经过以上运算，计算机就可以得到(a+b)\*c的运算结果e了。逆波兰式除了可以实现上述类型的运算，它还可以派生出许多新的算法，数据结构，这就需要灵活运用了。逆波兰式只是一种序列体现形式。  

```
int precede(char op)
{ int x;
switch(op)
{
case '*': x=2; break;
case '/': x=2; break;
case '+': x=1; break;
case '-': x=1; break;
default : x=0;
}
return x;
}
char *RPExpression(char *e)
{/* 返回表达式e的逆波兰式 */
char *c;
c=(char*)malloc(sizeof(char)*20); //不能用char c[]
Stack s1;
InitStack(s1);
int i=0,j=0;
char ch;
Push(s1,'@');
ch=e[i++];
while(ch!= 0)
{
if(ch=='(')
{
Push(s1,ch);
ch=e[i++];
}
else if(ch==')')
{
while(Top(s1)!='(')
{
Pop(s1,c[j++]);
}
/* to[j++]=pop(&s1);*/
Pop(s1,ch);
ch=e[i++];
}
else if(ch=='+'ch=='-'ch=='*'ch=='/')
{
char w;
w=Top(s1);
while(precede(w)>=precede(ch))
{
Pop(s1,c[j++]);
w=Top(s1);
}
Push(s1,ch);
ch=e[i++];
}
else
{
//while((ch<='z'&&ch>='a')(ch<='Z' && ch>='A')){
c[j++]=ch;
ch=e[i++];
//}
//c[j++]=' ';
}
}
Pop(s1,ch);
while(ch!='@')
{
c[j++]=ch;
Pop(s1,ch);
}
//c[j++]=;
c[j++]=0;
return c;
}
```