---
title: 7-2 两个有序链表序列的合并 (20分)
tags: []
id: '238'
categories: 数据结构与算法
date: 2020-03-09 18:44:38
---

已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。

### 输入格式:

输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。

### 输出格式:

在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出`NULL`。

### 输入样例:

```
1 3 5 -1
2 4 6 8 10 -1
```

### 输出样例:

```
1 2 3 4 5 6 8 10
```

```
#include <iostream>
#include <malloc.h>
using namespace std;
typedef int Status;
typedef int Elemtype;
typedef struct LNode
{
    Elemtype data;
    LNode *next;
}LNode,*LinkList;

LinkList endCreate()
{
    LinkList L,p,s;
    Elemtype e;
    L=(LinkList)malloc(sizeof(LNode));
    L->next=NULL;
    p=L;
    cin>>e;
    while (e!=-1)
    {
        s=(LinkList)malloc(sizeof(LNode));
        s->data=e;
        p->next=s;
        p=s;
        cin>>e;
    }
    p->next=NULL;
    return L;
}

LinkList headCreate()
{
    LinkList L,s;
    Elemtype e;
    L=(LinkList)malloc(sizeof(LNode));
    L->next=NULL;
    cin>>e;
    while (e!=-1)
    {
        s=(LinkList)malloc(sizeof(LNode));
        s->data=e;
        s->next=L->next;
        L->next=s;
        cin>>e;
    }
    return L;
}

void print(LinkList list)
{
    LinkList e;
    e=list->next;
    if(!e)
    {
        cout<<"NULL";
    } else {
        while (e->next) {
            cout << e->data << " ";
            e = e->next;
        }
        cout << e->data;
    }
}
void merge(LinkList L1,LinkList L2,LinkList &L3)
{
    LinkList l1=L1->next,l2=L2->next,l3;
    l3=L3=L1;
    while (l1&&l2)
    {
        if (l1->data<=l2->data)
        {
            l3->next=l1;
            l3=l1;
            l1=l1->next;
        } else
        {
            l3->next=l2;
            l3=l2;
            l2=l2->next;
        }
    }
    l3->next=l1?l1:l2;
}
int main()
{
    LinkList L1,L2,L3;
    L1=endCreate();
    L2=endCreate();
    merge(L1,L2,L3);
    print(L3);
}
```

这道题两点重点，第一是实现merge操作。传进去两个链表和第三个的引用，然后一直判断直到某一个结束，如果L3后边是L1说明L1还有剩下的，如果不是说明剩下的都是L2后边；

第二个是输出，需要注意如果是空就输出NULL，他是让打印出NULL而不是return。。。