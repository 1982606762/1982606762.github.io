---
title: 7-1 银行业务队列简单模拟 (25分)
tags: []
id: '311'
categories:
  - - c/c++语言
date: 2020-04-05 17:19:11
---

设某银行有A、B两个业务窗口，且处理业务的速度不一样，其中A窗口处理速度是B窗口的2倍 —— 即当A窗口每处理完2个顾客时，B窗口处理完1个顾客。给定到达银行的顾客序列，请按业务完成的顺序输出顾客序列。假定不考虑顾客先后到达的时间间隔，并且当不同窗口同时处理完2个顾客时，A窗口顾客优先输出。

### 输入格式:

输入为一行正整数，其中第1个数字N(≤1000)为顾客总数，后面跟着N位顾客的编号。编号为奇数的顾客需要到A窗口办理业务，为偶数的顾客则去B窗口。数字间以空格分隔。

### 输出格式:

按业务处理完成的顺序输出顾客的编号。数字间以空格分隔，但最后一个编号后不能有多余的空格。

### 输入样例:

```
8 2 1 3 9 4 11 13 15
```

### 输出样例:

```
1 3 2 9 11 4 13 15
```

```
#include<iostream>
#include<stdio.h>
#define MAXSIZE 1000
#define OVERFLOW -2
#define OK 1
#define ERROR -1
using namespace std;
typedef struct
{
    int *base;
    int front;
    int rear;
} SqQueue;
int InitQueue(SqQueue &Q)
{
    Q.base=new int[MAXSIZE];
    if(!Q.base)
        return OVERFLOW;
    Q.front=Q.rear=0;
    return OK;
}
int DeQueue(SqQueue &Q,int &e)
{
    if(Q.front==Q.rear)
        return ERROR;
    e=Q.base[Q.front];
    Q.front=(Q.front+1)%MAXSIZE;
    return OK;
}
void Print(int *arr,int n)
{
    cout<<arr[0];
    for(int i=1;i<n;i++)
        cout<<" "<<arr[i];
}
int main()
{
    SqQueue A,B;
    InitQueue(A);
    InitQueue(B);
    int N,data,tmp,i=0;
    cin>>N;
    int result[N];
    for(int i=0; i<N; i++)
    {
        cin>>data;
        if(data%2!=0)
        {
            if((A.rear+1)%MAXSIZE==A.front)
                return ERROR;
            A.base[A.rear]=data;
            A.rear=(A.rear+1)%MAXSIZE;
        }
        else
        {
            if((B.rear+1)%MAXSIZE==B.front)
                return ERROR;
            B.base[B.rear]=data;
            B.rear=(B.rear+1)%MAXSIZE;
        }
    }
    while((A.front!=A.rear)&&(B.front!=B.rear))
    {
        DeQueue(A,tmp);
        result[i++]=tmp;
        DeQueue(A,tmp);
        result[i++]=tmp;
        DeQueue(B,tmp);
        result[i++]=tmp;
    }
    while(A.front!=A.rear)
    {
        DeQueue(A,tmp);
        result[i++]=tmp;
    }
    while(B.front!=B.rear)
    {
        DeQueue(B,tmp);
        result[i++]=tmp;
    }
    Print(result,N);
}
```