---
title: 7-2 堆栈操作合法性 (20分)
tags: []
id: '305'
categories:
  - - c/c++语言
date: 2020-03-31 16:14:40
---

假设以`S`和`X`分别表示入栈和出栈操作。如果根据一个仅由`S`和`X`构成的序列，对一个空堆栈进行操作，相应操作均可行（如没有出现删除时栈空）且最后状态也是栈空，则称该序列是合法的堆栈操作序列。请编写程序，输入`S`和`X`序列，判断该序列是否合法。

### 输入格式:

输入第一行给出两个正整数N和M，其中N是待测序列的个数，M（≤50）是堆栈的最大容量。随后N行，每行中给出一个仅由`S`和`X`构成的序列。序列保证不为空，且长度不超过100。

### 输出格式:

对每个序列，在一行中输出`YES`如果该序列是合法的堆栈操作序列，或`NO`如果不是。

### 输入样例：

```
4 10
SSSXXSXXSX
SSSXXSXXS
SSSSSSSSSSXSSXXXXXXXXXXX
SSSXXSXXX
```

### 输出样例：

```
YES
NO
NO
NO
```

```
#include<iostream>
#include<string>
using namespace std;

#define MAXSIZE  100
#define ADDSIZE  10
typedef int Status;
typedef char SElemType;

typedef struct {
    SElemType *base;
    SElemType *top;
    int stacksize;
} SqStack;

Status Initstack(SqStack &s,int e=MAXSIZE)
{
    s.base=new SElemType[e];
    s.top=s.base;
    s.stacksize=e;
    return 1;
}


Status push(SElemType e,SqStack &s)
{
    if(s.top-s.base>=s.stacksize)
    {
        /*s.base=(SElemType*)realloc(s.base,(s.stacksize+ADDSIZE)* sizeof(SElemType));
        if(!s.base)
            exit(EOVERFLOW);
        s.top=s.base+s.stacksize;
        s.stacksize+=ADDSIZE;*/
        return 0;
    }
    *s.top++=e;
    return 1;
}

Status pop(SElemType &e,SqStack &s)
{
    if(s.top==s.base)return 0;
    e=*--s.top;
    return 1;
}

Status GetTop(SElemType &e,SqStack &s)
{
    if(s.top==s.base)return 0;
    e=*(s.top-1);
    return 1;
}

bool Isright(string s,int e)
{
    int i=0,f=1;
    SqStack sq;
    Initstack(sq,e);
    while (s[i] != '\0')
    {
        if(s[i]=='S') {
            if (push(s[i],sq) == 1)
                i++;
            else
                {
                f = 0;
                break;
            }
        }
        else {
            if (pop(s[i],sq) == 1)
                i++;
            else {
                f = 0;
                break;
            }
        }
    }
    if(sq.top==sq.base&&s[i]=='\0')
        f=1;
    else
        f=0;
    return f == 1;
}
bool IsRight(string s,int L)
{
    int i=0,flag=1;
    SqStack sq;
    Initstack(sq,L);
    while(s[i]!='\0')
    {
        if(s[i]=='S')
        {
            if(push(s[i],sq)==1)
                i++;
            else
            {
                flag=0;
                break;
            }
        }
        else
        {
            if(pop(s[i],sq)==1)
                i++;
            else
            {
                flag=0;
                break;
            }
        }
    }
    if((sq.top==sq.base) && s[i]=='\0')
        flag=1;
    else
        flag=0;
    return flag == 1;
}

int main()
{
    int m,n;
    string ss;
    cin>>m>>n;
    for (int u = 0; u < m; ++u) {
        cin>>ss;
        if (IsRight(ss,n)== true)
            cout<<"YES"<<endl;
        else
            cout<<"NO"<<endl;
    }
}
```