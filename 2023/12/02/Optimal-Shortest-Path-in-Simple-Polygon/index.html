<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/32*32.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32*32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16*16.ico">
  <link rel="mask-icon" href="/images/32*32.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.zhaoxuanlang.cn","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"changyan","storage":true,"lazyload":false,"nav":null,"activeClass":"changyan"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="Let P be a simple polygon with n sides and this report will give a method to preprocess the polygon so that given two query points p and q inside P, the length of the shortest path inside the polygon">
<meta property="og:type" content="article">
<meta property="og:title" content="Optimal-Shortest-Path-in-Simple-Polygon">
<meta property="og:url" content="https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/index.html">
<meta property="og:site_name" content="松鼠小筑">
<meta property="og:description" content="Let P be a simple polygon with n sides and this report will give a method to preprocess the polygon so that given two query points p and q inside P, the length of the shortest path inside the polygon">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/Optimal-Shortest-Path-in-Simple-Polygon/Image%202.jpeg">
<meta property="og:image" content="https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/Optimal-Shortest-Path-in-Simple-Polygon/chains%20example.png">
<meta property="og:image" content="https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/Optimal-Shortest-Path-in-Simple-Polygon/null%20edge.png">
<meta property="og:image" content="https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/Optimal-Shortest-Path-in-Simple-Polygon/Untitled-7302661.png">
<meta property="og:image" content="https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/Optimal-Shortest-Path-in-Simple-Polygon/condition2.png">
<meta property="og:image" content="https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/Optimal-Shortest-Path-in-Simple-Polygon/proof%20figure1.png">
<meta property="og:image" content="https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/Optimal-Shortest-Path-in-Simple-Polygon/proof%20example2.png">
<meta property="og:image" content="https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/Optimal-Shortest-Path-in-Simple-Polygon/proof%20image3.png">
<meta property="og:image" content="https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/Optimal-Shortest-Path-in-Simple-Polygon/leftretrieval.png">
<meta property="og:image" content="https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/Optimal-Shortest-Path-in-Simple-Polygon/rightretrival.png">
<meta property="og:image" content="https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/Optimal-Shortest-Path-in-Simple-Polygon/derived%20example.png">
<meta property="article:published_time" content="2023-12-02T16:22:44.000Z">
<meta property="article:modified_time" content="2023-12-02T16:32:09.737Z">
<meta property="article:author" content="Xuanlang">
<meta property="article:tag" content="ShortestPath">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/Optimal-Shortest-Path-in-Simple-Polygon/Image%202.jpeg">


<link rel="canonical" href="https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/","path":"2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/","title":"Optimal-Shortest-Path-in-Simple-Polygon"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Optimal-Shortest-Path-in-Simple-Polygon | 松鼠小筑</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?2c6ad69c6dce83b3987864c3d69796db"></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">松鼠小筑</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学习笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">27</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">11</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">92</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#introduction"><span class="nav-number">1.</span> <span class="nav-text">1. Introduction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#the-balanced-hierarchical-decomposition-of-p"><span class="nav-number">2.</span> <span class="nav-text">2. The balanced
hierarchical decomposition of P</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shortest-paths-and-the-polygon-decomposition"><span class="nav-number">3.</span> <span class="nav-text">3. Shortest paths
and the polygon decomposition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hourglass-and-shortest-paths"><span class="nav-number">4.</span> <span class="nav-text">4. Hourglass and Shortest
Paths</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#introduction-to-hourglass"><span class="nav-number">4.1.</span> <span class="nav-text">Introduction to Hourglass</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#specifications-and-use"><span class="nav-number">4.2.</span> <span class="nav-text">4.1 Specifications and Use</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#operation1-concatenation"><span class="nav-number">4.2.1.</span> <span class="nav-text">Operation1: Concatenation</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#the-chain-data-structure"><span class="nav-number">4.3.</span> <span class="nav-text">4.2 The Chain Data Structure</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string-data-structure"><span class="nav-number">4.4.</span> <span class="nav-text">String data structure</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hourglass-data-structure-implementation"><span class="nav-number">4.5.</span> <span class="nav-text">hourglass data
structure: Implementation</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#improved-query-time-bounds"><span class="nav-number">5.</span> <span class="nav-text">5. Improved Query Time bounds</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xuanlang"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Xuanlang</p>
  <div class="site-description" itemprop="description">业精于勤荒于嬉，行成于思毁于随</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/1982606762" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;1982606762" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zxl17302206700@gmail.com" title="E-Mail → mailto:zxl17302206700@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.linkedin.com/in/xuanlang/" title="Linkedin → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;xuanlang&#x2F;" rel="noopener" target="_blank"><i class="fa fa-linkedin fa-fw"></i>Linkedin</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Xuanlang">
      <meta itemprop="description" content="业精于勤荒于嬉，行成于思毁于随">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="松鼠小筑">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Optimal-Shortest-Path-in-Simple-Polygon
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-12-02 17:22:44 / 修改时间：17:32:09" itemprop="dateCreated datePublished" datetime="2023-12-02T17:22:44+01:00">2023-12-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="Optimal-Shortest-Path-in-Simple-Polygon" href="/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::b56506efd8271fdd5039bf3fe9f8434f" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>29k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>53 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Let P be a simple polygon with n sides and this report will give a
method to preprocess the polygon so that given two query points p and q
inside P, the length of the shortest path inside the polygon from p to q
can be found in time O(log n).</p>
<span id="more"></span>
<h3 id="introduction">1. Introduction</h3>
<p>The algorithm's aim is to solve the Euclidean shortest path problem
and focuses on a simple one: moving a point inside a simple polygon in
the plane.</p>
<p>All the related algorithms are based on a triangulation of the
polygon, the previous algorithms pre-select a fixed source point, so one
of the points is fixed. When it comes to the situation neither endpoint
of the path is predetermined, they will need linear time to find the
shortest path. This new algorithm can find the shortest path between any
two points. It needs <strong>linear time to build</strong> and
<strong>do the query to find the length in logarithmic time</strong>.
Also, it needs <strong>time proportional to the number of turns to get
the path itself. </strong></p>
<p>The idea is to go through some subpolygons, each of them containing
information about the shortest paths inside it. When we query, we gather
this information to find the shortest path from source to
destination.</p>
<h3 id="the-balanced-hierarchical-decomposition-of-p">2. The balanced
hierarchical decomposition of P</h3>
<p>First, we need to split the main polygon P into subpolygons. There's
a polygon cutting theorem as follows:</p>
<p><strong>any simple polygon of at least 4 vertices has a diagonal that
divides it into two subpolygons with roughly equal size</strong></p>
<p>If we apply it recursively then we have a triangulation of P. Then we
can use a binary tree S to denote the split, each layer stands for a
split stage, root means the first split's diagonal, children of root s
stands for the diagonals of these two subpolygons. These subpolygons are
called <strong>cell</strong> and they are very important.<img
src="Optimal-Shortest-Path-in-Simple-Polygon/s5i8dCP.png"
alt="s5i8dCP" /></p>
<p>Some Notation:</p>
<ul>
<li>d: diagonal</li>
<li><span class="math inline">\(P_d\)</span>: the diagonal d cuts <span
class="math inline">\(P_d\)</span> into two cells</li>
<li>S: binary split tree</li>
<li><span class="math inline">\(L(d)\)</span>: depth of d in S, e.g.
l(d1) = 0, l(d2) = 1.</li>
<li>H(d): height of d in S, e.g. H(d2) = L(d7) - L(d2) = 2</li>
</ul>
<p>Cells not associated with a diagonal are those small triangles after
the split. They have a depth of 1 greater than the depth of its bounding
diagonal. e.g. triangle IHG has a depth of 4.</p>
<p>In order to refer to diagonal pairs the shortest path passes through
we need <strong>the factor graph <span
class="math inline">\(S^*\)</span></strong>. It's defined as follows: we
get <span class="math inline">\(S^*\)</span> from S by adding edges
connecting each d to all diagonals bounding <span
class="math inline">\(P_d\)</span>. Following is <span
class="math inline">\(S^*\)</span> from the previous tree.<img
src="Optimal-Shortest-Path-in-Simple-Polygon/uzOTVXZ.png"
alt="uzOTVXZ" /></p>
<p>edge of <span class="math inline">\(S^*\)</span> represents a pair of
diagonals of the cell's bounding.</p>
<p><strong>Lemma1: The size of the factor graph <span
class="math inline">\(S^*\)</span> is O(n)$</strong></p>
<p>We can get S and <span class="math inline">\(S^*\)</span> in
<strong>O(nloglogn) + O(n)</strong> time.</p>
<h3 id="shortest-paths-and-the-polygon-decomposition">3. Shortest paths
and the polygon decomposition</h3>
<p>This section analyzes the sequence of diagonals crossed by the
shortest path in P, which is the sequence of cells.</p>
<p>This sequence can be discovered quickly once we know the triangles
containing the two endpoints. Then using the pre-computed information
inside each adjacent pair of diagonals we can find the path.</p>
<p>To begin with, we have two points p and q in P which are starting
point and ending point. Then the path from p to q crosses several
diagonals, we call them <strong>separating for p and q</strong>.
Following are some properties of separatings:</p>
<ul>
<li>To pass a separating the shortest path needs to pass all separatings
on the side of q first.</li>
<li>Adjacent separating have different depths</li>
<li>Between two separatings with the same depth, there's one with lesser
depth.</li>
</ul>
<p>Then we need to define a subsequence of separatings. First we have
<strong>principal separating diagonal <span class="math inline">\(\hat
d\)</span></strong> which is the lowest common ancestor in S of all the
separating diagonals, e.g.d2 is principal if p is in IHG and q is in
AKF. Also we define the separating diagonals nearest p and q also to be
principal diagonals and we call them $d_p $ and <span
class="math inline">\(d_q\)</span> .</p>
<p>Then we have <strong><span class="math inline">\(D_p\)</span> to be a
subsequence of the separating diagonals between <span
class="math inline">\(d_p\)</span> and <span class="math inline">\(\hat
d\)</span>. </strong> e.g. d5 and d7 are two new principal diagonals.
The <strong>principal diagonals are then just those in <span
class="math inline">\(D_p\)</span> together with those in <span
class="math inline">\(D_q\)</span></strong>.</p>
<blockquote>
<p>Scan through this sequence from <span
class="math inline">\(d_p\)</span> to <span class="math inline">\(\hat
d\)</span> and keep track of the minimum depth seen so far.</p>
<p>During the scan, discard all diagonals with depth greater than the
current minimum.</p>
<p>The remaining diagonals are of strictly increasing depth (by the
lacuna property) and form <span class="math inline">\(D_p\)</span>.</p>
<p>The sequence <span class="math inline">\(D_p\)</span>, is defined
symmetrically, proceeding from <span class="math inline">\(d_p\)</span>
to <span class="math inline">\(\hat d\)</span>. The principal diagonals
are then just those in <span class="math inline">\(D_p\)</span> together
with those in <span class="math inline">\(D_p\)</span>.</p>
</blockquote>
<blockquote>
<p>make d2 to be <span class="math inline">\(\hat d\)</span> and d5 to
be <span class="math inline">\(d_p\)</span> and d7 to be <span
class="math inline">\(d_q\)</span>.</p>
<p>Then <span class="math inline">\(D_p\)</span> is d5-d2, <span
class="math inline">\(D_q\)</span> is d7-d4-d2.</p>
</blockquote>
<p><strong>The calculation of <span class="math inline">\(D_p\)</span>
can be done in log time</strong>: we can scan in the tree S from <span
class="math inline">\(d_p\)</span> to <span class="math inline">\(\hat
d\)</span> and check all nodes(diagonals in P) and see if they are
between <span class="math inline">\(\hat d\)</span> and <span
class="math inline">\(d_p\)</span> in P(This can be done in constant
time).If it's between then it belongs to <span
class="math inline">\(D_p\)</span>.</p>
<p><strong>Conclusion</strong>: We can get a sequence of separatings in
O(logn) time and the "concatenation" of the shortest path from p to q
lies in.</p>
<h3 id="hourglass-and-shortest-paths">4. Hourglass and Shortest
Paths</h3>
<h4 id="introduction-to-hourglass">Introduction to Hourglass</h4>
<p>We need to use an hourglass structure to represent the shortest paths
between two diagonals.</p>
<p>Each hourglass is associated with an edge of the factor graph because
an edge has two nodes( two separate diagonals) and can form an
hourglass.</p>
<p><strong>funnel</strong>: a funnel represents the shortest path from a
source s to two endpoints of an edge or a diagonal. Let <span
class="math inline">\(p_1,p_2\)</span> be two endpoints of a diagonal
and s be the source, then from s to endpoints' shortest path have a
shared edge, then at some point, they will separate. We call this point
A <strong>apex of the funnel</strong>. Each of the funnel paths is
<em>inward convex</em>.</p>
<figure>
<img
src="Optimal-Shortest-Path-in-Simple-Polygon/image-20230914105328713%20PM-4724817.png"
alt="image-20230914105328713 PM" />
<figcaption aria-hidden="true">image-20230914105328713 PM</figcaption>
</figure>
<p>New Notation:</p>
<ul>
<li><span class="math inline">\(\pi(p,q)\)</span>: the shortest path
inside P that connects points p and q.</li>
<li>Hourglass: let <span class="math inline">\(\bar {AB}\)</span> and
<span class="math inline">\(\bar {CD}\)</span> be two diagonals of P and
BACD is the subsequence of vertex, then the union of the two paths <span
class="math inline">\(\pi(A,C)\)</span> and <span
class="math inline">\(\pi(B,D)\)</span> is the <em>hourglass</em> of
<span class="math inline">\(\bar {AB}\)</span> and <span
class="math inline">\(\bar {CD}\)</span>.</li>
<li>String: If the paths share any vertices, then the hourglass is
essentially two funnels joined by a polygonal path between their apexes.
We call this shortest path between the apexes <em>string</em>.</li>
</ul>
<figure>
<img data-src="Optimal-Shortest-Path-in-Simple-Polygon/Image%202.jpeg"
alt="Image 2" />
<figcaption aria-hidden="true">Image 2</figcaption>
</figure>
<p>If we know the path from s to a/p1/p2 then we can use the funnel to
determine the length of <span class="math inline">\(\pi(s,q)\)</span>
for every q on d. There's only one tangent v from q to the funnel, so we
can use the path <span class="math inline">\(\pi(s,a\)</span>) + (a,v) +
tangent(v,q) as the shortest path <span
class="math inline">\(\pi(s,q)\)</span>.</p>
<p>As the funnel is from a fixed source, we need to get the shortest
path from one diagonal to another diagonal, so we introduce a new
structure hourglass. It's represented by two diagonals AB and CD. The
union of two paths <span class="math inline">\(\pi(A,C)\)</span> and
<span class="math inline">\(\pi(B,D)\)</span> is the hourglass of AB and
CD. If the paths share any vertices then it's a <strong>closed
hourglass</strong>, or else there's a segment with one endpoint on AB
and the other on CD that avoids the polygon, it's an <strong>open
hourglass</strong>.</p>
<figure>
<img
src="Optimal-Shortest-Path-in-Simple-Polygon/image-20230915122055515%20AM-4730059.png"
alt="image-20230915122055515 AM" />
<figcaption aria-hidden="true">image-20230915122055515 AM</figcaption>
</figure>
<p>If we want to find the point's shortest path from AB to CD, if it's
closed then it's just two funnels and one string. If it's open then
there will be 2 cases:</p>
<ol type="1">
<li>p,q are visible: pq is the shortest path</li>
<li>p,q aren't visible, there will be 2 cases
<ol type="1">
<li>P,q are on one side with A, C: the shortest path is $ tangent(p,
(A,C) )+ $tangents in <span class="math inline">\(\pi(A,C) +
tangent(q,\pi(A,C))\)</span></li>
<li>p,q are far away: the shortest path is <span
class="math inline">\(tangent(p,\pi(A,C))+\)</span> the portions of the
hourglass chains needed to connect the tangents <span
class="math inline">\(+ tangent(q,\pi(B,C))\)</span>.</li>
</ol></li>
</ol>
<p>Hourglasss are very suitable for concat. However, there are several
different cases:</p>
<ol type="1">
<li><p>Both hourglasses are closed: (d1,d2),(d2,d3),(d1,d3)are all
closed, then the shortest path uses two funnels d1,d3 and old string
augmenting shortest path <span
class="math inline">\(\pi(a,a&#39;)\)</span>.</p>
<figure>
<img
src="Optimal-Shortest-Path-in-Simple-Polygon/image-20230917104655314%20PM-4983621.png"
alt="image-20230917104655314 PM" />
<figcaption aria-hidden="true">image-20230917104655314 PM</figcaption>
</figure></li>
<li><p>One hourglass is closed and the other is open, we define the
closed one is <span class="math inline">\((d_1,d_2)\)</span> and the
open one is <span class="math inline">\((d_2,d_3)\)</span>. Then we have
a point a as the funnel of <span class="math inline">\(d_2\)</span>.
First, we find the apex a' in the funnel (a,<span
class="math inline">\(d_3\)</span>). Second, we get shortest path in
funnel <span class="math inline">\((a,d_1)\)</span>. Third, we add the
shortest path with <span class="math inline">\(\pi(a,a&#39;)\)</span>
and get the final shortest path.</p>
<figure>
<img
src="Optimal-Shortest-Path-in-Simple-Polygon/image-20230917104818897%20PM-4983713.png"
alt="image-20230917104818897 PM" />
<figcaption aria-hidden="true">image-20230917104818897 PM</figcaption>
</figure></li>
<li><p>If both are open, then the four common tangents that touch one
chain from each hourglass determine the result.</p>
<figure>
<img
src="Optimal-Shortest-Path-in-Simple-Polygon/image-20230917111151764%20PM.png"
alt="image-20230917111151764 PM" />
<figcaption aria-hidden="true">image-20230917111151764 PM</figcaption>
</figure></li>
</ol>
<p>Now we can only find shortest paths from diagonals of hourglasses,
but it's easy to extend to all points inside the hourglass. Suppose we
have p and q which we want to find the shortest path then we can make
tangents from p,q to the nearest diagonals <span
class="math inline">\(d_p\)</span> and <span
class="math inline">\(d_q\)</span>. Or we can see p,q as two small
diagonals, and we just contact them with <span
class="math inline">\(d_p,d_q\)</span> and get 3 hourglasses, and they
are a single closed hourglass and we can get the shortest path between p
and q.</p>
<h4 id="specifications-and-use">4.1 Specifications and Use</h4>
<p>This subsection shows a data structure that allows efficient
representation and manipulation of hourglass. It also specifies the
operation the structure must support and the allowable space and time
complexities of each(operations).</p>
<p>New Notation:</p>
<ul>
<li><span class="math inline">\(H(d_1,d_2)\)</span> : the hourglass
between <span class="math inline">\(d_1\)</span> and <span
class="math inline">\(d_2\)</span>.</li>
</ul>
<h5 id="operation1-concatenation">Operation1: Concatenation</h5>
<p>The concatenation is finding common tangents between pairs of convex
polygonal chains or between points (degenerate convex chain). So we have
the following requirements:</p>
<ol type="1">
<li>If the tangent from one point to the hourglass <span
class="math inline">\(H(d_1,d_2)\)</span> and <span
class="math inline">\(H(d_2,d_3)\)</span> can be found in <span
class="math inline">\(t_1,t_2\)</span>, then the common tangent of the
two hourglasses can be found in time<span
class="math inline">\(O(t_1+t_2)\)</span>.</li>
<li>If the tangent from one point to the hourglass <span
class="math inline">\(H(d_1,d_2)\)</span> and <span
class="math inline">\(H(d_2,d_3)\)</span> can be found in <span
class="math inline">\(t_1,t_2\)</span>, then the hourglass <span
class="math inline">\(H(d_1,d_3)\)</span> can be constructed in <span
class="math inline">\(O(t_1+t_2)\)</span> time <strong>and additional
space</strong>, and the original two hourglasses are unaltered by
concatenation.</li>
</ol>
<p>The following two requirements help the query operation and make it
faster.</p>
<ol start="3" type="1">
<li>If the tangent from one point to the hourglass <span
class="math inline">\(H(d_1,d_2)\)</span> and <span
class="math inline">\(H(d_2,d_3)\)</span> can be found in <span
class="math inline">\(t_1,t_2\)</span>, then tangents to <span
class="math inline">\(H(d_1,d_3)\)</span> can be found in time max<span
class="math inline">\((t_1,t_2) + C\)</span>. For some constant C.</li>
<li>if tangents from a point to <span
class="math inline">\(H(d_1,d_2)\)</span> can be found in time t, the
length of the shortest path between d1 and d2 can be found in O(t)
time.The path itself can be found in O(t+m) time and m is the number of
turns in the path.</li>
</ol>
<p>Then we can save some hourglasses and concat them to find the
necessary hourglass to find the shortest path.</p>
<p>Previously we built a tree while doing triangulation and adding
diagonals of depth k at time k(one layer at a time). Now we can
<strong>do it backwards</strong>:</p>
<ol type="1">
<li>Delete a diagonal with the greatest depth in S</li>
<li>merge two adjacent cells of the diagonal and create a new cell</li>
<li>Construct an hourglass between the pair of diagonals.</li>
</ol>
<p>After all diagonals are removed we <strong>have hourglasses
corresponding to all the edges in <span
class="math inline">\(S^*\)</span></strong>.</p>
<p>During this construction, there's an inductive invariant: before the
diagonal of depth k is deleted, all hourglassed in cells with depth
greater than k have been computed. The hourglasses built have special
properties, and we can use them to prove the linear time and space
bound. As the procedure combines hourglasses layer by layer, so the time
is logarithmic(with a connection of the height of the triangulation
tree), and the time could be linear(one by one following the chain). To
express this log bound we need a new notion:</p>
<p>New Notation:</p>
<ul>
<li><span class="math inline">\(\lambda(d_1,d_2)\)</span>: if two
diagonals <span class="math inline">\(d_1\)</span> and <span
class="math inline">\(d_2\)</span> are linked in <span
class="math inline">\(S^*\)</span> and they lie on the boundary of a
cell, then <span class="math inline">\(\lambda(d_1,d_2)\)</span> is the
log of the size of the cell.</li>
</ul>
<p><strong>Lemma 2</strong>: If <span class="math inline">\(d_1\)</span>
and <span class="math inline">\(d_2\)</span> are linked by an edge in
the factor graph, it's possible to find the tangents through a point to
the hourglass <span class="math inline">\(H(d_1,d_2)\)</span> in time
<span class="math inline">\(O(\lambda(d_1,d_2))\)</span>.</p>
<p>Using this Lemma we are going to prove the linearity of the
construction.</p>
<p>We can constructe one hourglass obtained by concatenating two
hourglasses across diagonal d in time and space proportional to the
logarithm of the size of <span class="math inline">\(P_d\)</span>, and
this quantity is proportional to h(d). The height is less than the
height of two diagonals of the new hourglass, make one of the new
diagonal to be d', there are O(h(d')) edges in <span
class="math inline">\(S^*\)</span> joining d to lower diagonals, the
hourglasses corresponding to these edges can be built in <span
class="math inline">\(O((h(d&#39;))^2)\)</span> time and space.<img
src="Optimal-Shortest-Path-in-Simple-Polygon/uzOTVXZ.png"
alt="uzOTVXZ" /></p>
<p>Overall the construction takes time and space proportional to O(n).
After build these hourglasses they can answer shortest path queries in
<span class="math inline">\(O(log^2n)\)</span> time:</p>
<p>Between p and q there are O(log n) hourglasses and we can concat them
into a single long hourglass using O(log n) concatenations. From
previous we know each concatenation takes O(log n) time so it's <span
class="math inline">\(O(log^2n)\)</span> time. Finally, we can view p
and q as diagonals and concatenate <span class="math inline">\(H(p,d_p),
H(d_p,d_q),H(d_q,q)\)</span> to get H(p,q) in O(log n) additional time,
this hourglass is a string and it's the shortest path from p to q. As
it's a string we can get the length of the path, and the path itself can
be extracted in additional time by the forth requirement.</p>
<h4 id="the-chain-data-structure">4.2 The Chain Data Structure</h4>
<p>Convex polygonal chains are the basic constituents of hourglasses, it
represents ordered convex chains by binary trees. We need to build
hourglasss from chains, so chains need to satisfy some analogous
conditions. A chain is the convex hull of its subchains.</p>
<p>First, each chain is a shortest path inside P, if the chain has
endpoints A and B then the chain is <span
class="math inline">\(\pi(A,B)\)</span>. Then the chain is convex and
cannot spiral. Also, the chain is equal to its own convex hull minus the
segment <span class="math inline">\(\bar {AB}\)</span>.</p>
<p>there are two types of the chain: a trivial chain and a derived
chain.</p>
<p>Trivial chain: a single polygon edge</p>
<p>Derived chain: the convex hull of two subchains, each of them may
contribute no edges to the shortest path.</p>
<figure>
<img
src="Optimal-Shortest-Path-in-Simple-Polygon/derived%20and%20trivial.png"
alt="derived and trivial" />
<figcaption aria-hidden="true">derived and trivial</figcaption>
</figure>
<figure>
<img data-src="Optimal-Shortest-Path-in-Simple-Polygon/chains%20example.png"
alt="chains example" />
<figcaption aria-hidden="true">chains example</figcaption>
</figure>
<p>the derived chain contains the outer common tangent of two subchains,
and sometimes there are no tangents. A tangent edge may consist of a
single point, we need to ensure there are not too many null edges in any
chain. If a null edge in <span class="math inline">\(\pi(A, B)\)</span>
or <span class="math inline">\(\pi(B, C)\)</span> coincides with one
endpoint of the outer common tangent of <span
class="math inline">\(\pi(A, B)\)</span> and <span
class="math inline">\(\pi(B, C)\)</span>, we do not include the null
edge in the derived chain <span class="math inline">\(\pi(A,
C)\)</span>. As a result, no chain contains adjacent null edges. This is
illustrated in the following figure. Here at vertex D, there's a null
edge from <span class="math inline">\(\pi(A, B)\)</span> and also one
from <span class="math inline">\(\pi(B,C)\)</span>. After concatenation,
these two null edges no longer exist in the new chain <span
class="math inline">\(\pi(A,C)\)</span>.</p>
<figure>
<img data-src="Optimal-Shortest-Path-in-Simple-Polygon/null%20edge.png"
alt="null edge" />
<figcaption aria-hidden="true">null edge</figcaption>
</figure>
<p>Also, no chain should have adjacent collinear edges, if a common
tangent is collinear with an edge then we can extend the tangent edge to
delete the collinear dege.</p>
<p>The chain supports two important operations: tangent-finding and
constructing a chain from its subchains. <strong>The chain data
structure can be denoted with a binary tree: you can use a leaf node to
represent a trivial chain, and use a node that contains the common
tangent of the subchains and pointers to the nodes to represent a
derived chain.</strong> So we can build the tree based on a chain like
in the next figure.</p>
<figure>
<img
src="Optimal-Shortest-Path-in-Simple-Polygon/chain%20and%20tree.png"
alt="chain and tree" />
<figcaption aria-hidden="true">chain and tree</figcaption>
</figure>
<p>To do the tangent-finding, first, we are given a chain <span
class="math inline">\(\pi(A,C)\)</span> and a point X outside the convex
hull. <strong>The task is to find the two tangents from X to the
chain.</strong> We can look at the edge stored in node v which
represents <span class="math inline">\(\pi(A,C)\)</span> to find each
tangent, and then in constant time, we can determine which subchain the
tangent touches, and then find the tangent by recursively searching in
the subchain's tree. <strong>This search takes time proportional to the
height of the tree v.</strong></p>
<p>Another query is to find the inner and outer common tangents of two
chains. neither chain is contained in the convex hull of the other.
Using the techniques of Overmars and van Leeuwen,<strong>the tangents
can be found in time proportional to the sum of the heights of the trees
represent <span class="math inline">\(\pi(A,B)\)</span> <span
class="math inline">\(\pi(C,D)\)</span></strong>.</p>
<p>When we use chain data structure in hourglass we only need to compute
one tangent at a time, so we need to modify the tangent-finding
algorithm a bit for that. We need to specify which tangent we want
because there are two tangents for one chain. We can define left and
right for each chain by taking the convex side to be up.</p>
<figure>
<img data-src="Optimal-Shortest-Path-in-Simple-Polygon/Untitled-7302661.png"
alt="Untitled" />
<figcaption aria-hidden="true">Untitled</figcaption>
</figure>
<p>We have two chain conditions analogueue to the hourglass
condition:</p>
<p>C1: If the lines passing through a given query point and tangent to
chains <span class="math inline">\(\pi(A, B)\)</span> and <span
class="math inline">\(\pi(C, D)\)</span> can be found in times <span
class="math inline">\(t_1\)</span>, and <span
class="math inline">\(t_2\)</span>, the common tangents of the two
chains can be found in time O(t1+t2).</p>
<p>To illustrate this condition a bit more clear, we can refer to the
following figure. Given the assumtion the two tangents from a query
point to two chains can be found in <span
class="math inline">\(t_1\)</span> and <span
class="math inline">\(t_2\)</span>, we know in any 1 call we can find
two tangents in <span class="math inline">\(t_1 + t_2\)</span> time. In
most of the time these two tangents are not common tangents like green
lines in the figure, but after O(1) calls we can find a situation where
the two tangents are common tangents like the red lines in the figure.
So we can find the common tangents in time <span
class="math inline">\(O(t_1 + t_2)\)</span>.</p>
<figure>
<img data-src="Optimal-Shortest-Path-in-Simple-Polygon/condition2.png"
alt="condition2" />
<figcaption aria-hidden="true">condition2</figcaption>
</figure>
<p>C3:Suppose chain <span class="math inline">\(\pi(A, C)\)</span> is
built from subchains <span class="math inline">\(\pi(A, B)\)</span> and
<span class="math inline">\(\pi(B, C)\)</span>. If tangents from a point
to chains <span class="math inline">\(\pi(A, B)\)</span> and<span
class="math inline">\(\pi(B, C)\)</span> can be found in times t1 and
t2, tangents to their combined chain <span class="math inline">\(\pi(A,
C)\)</span> can be found in time max(t1,t2) + <constant>.</p>
<p>Also, condition 4 requires computing the length of the path in
hourglasses, so we need to store chain lengths in the chain data
structure. Consider the following figure, in this chain the node
representing <span class="math inline">\(\pi(A,E)\)</span> stores the
length of AB,BD and DE. The sum of these lengths is the length of
AE.</p>
<figure>
<img
src="Optimal-Shortest-Path-in-Simple-Polygon/image-2023101474210889%20PM.png"
alt="image-2023101474210889 PM" />
<figcaption aria-hidden="true">image-2023101474210889 PM</figcaption>
</figure>
<p>new notations:</p>
<p>If node v represents the chain of fig 9.</p>
<ul>
<li>v.tan : the tangent edge BD</li>
<li>v.llen: length of <span class="math inline">\(\pi(A,B)\)</span></li>
<li>v.rlen: length of <span class="math inline">\(\pi(C,E)\)</span></li>
<li>v.tlen: length of BD</li>
<li>v.len: length of <span class="math inline">\(\pi(A,E)\)</span> and
it's the sum of llen, rlen and tlen. If v is just a single edge, then
llen = rlen = 0. Len = tlen</li>
</ul>
<p>The following lemma helps us fill in the length fields of v:</p>
<p><strong>lemma3:</strong> Let v be the root of the tree representing
the chain <span class="math inline">\(\pi(A, E)\)</span> of Fig. 9. Let
u be a node in the tree whose edge u. tan appears in <span
class="math inline">\(\pi(A, E)\)</span>, and let X be the right
endpoint of u. tan. The length of the chain <span
class="math inline">\(\pi(A, X)\)</span> can be determined by looking at
the lengths stored at the nodes along the path from v to u in the
tree.</p>
<p><em>Proof.</em> The proof is based on classification discussion and
keep in mind that each node saves len, llen, rlen and tlen.</p>
<p>If u = v, then u.tan = <span
class="math inline">\(\overline{BD}\)</span>. The length of <span
class="math inline">\(\pi(A,X)\)</span> is just v.llen + u.tlen.</p>
<figure>
<img data-src="Optimal-Shortest-Path-in-Simple-Polygon/proof%20figure1.png"
alt="proof figure1" />
<figcaption aria-hidden="true">proof figure1</figcaption>
</figure>
<p>If u is in the left subtree of v, then only edges from the subchain
<span class="math inline">\(\pi(A,B)\)</span> contribute to <span
class="math inline">\(\pi(A,X)\)</span>. By induction we can find the
length of <span class="math inline">\(\pi(A,X)\)</span> by looking at
the lengths stored along the path from the left child of v down to u. In
this example from v to u we can get node <span
class="math inline">\(t_2\)</span>, and the length of <span
class="math inline">\(\pi(A,X)\)</span> is <span
class="math inline">\(t_2.llen + t_2.tlen + u.len\)</span>.</p>
<figure>
<img data-src="Optimal-Shortest-Path-in-Simple-Polygon/proof%20example2.png"
alt="proof example2" />
<figcaption aria-hidden="true">proof example2</figcaption>
</figure>
<p>If u is in the right subtree of v, then <span
class="math inline">\(\pi(A,X)\)</span> consists of <span
class="math inline">\(\pi(A,B),\overline{BD}\)</span> and some prefix of
<span class="math inline">\(\pi(D,E)\)</span>. Thus the length of <span
class="math inline">\(\pi(A,X)\)</span> is v.llen + v.tlen + the length
of <span class="math inline">\(\pi(D,X)\)</span>. This last term is the
same as the length of <span class="math inline">\(\pi(C,X)\)</span> -
the length of <span class="math inline">\(\pi(C,D)\)</span>. If t is the
right child of v, the node associated with <span
class="math inline">\(\pi(C,E)\)</span>, then the length of <span
class="math inline">\(\pi(A,X)\)</span> is v.len - t.len + the length of
<span class="math inline">\(\pi(C,X)\)</span>. By induction we can find
the length of <span class="math inline">\(\pi(C,X)\)</span> by looking
at the nodes on the path from t to u.</p>
<figure>
<img data-src="Optimal-Shortest-Path-in-Simple-Polygon/proof%20image3.png"
alt="proof image3" />
<figcaption aria-hidden="true">proof image3</figcaption>
</figure>
<p>To fill in the length fields of v we need to compute v.llen and
v.rlen. Using lemma3 we can know that we can get v.llen by looking at
the nodes along the path from a point u in the tree representing the
left subchain up to the root of the left subtree. this can be computed
in time proportional to the height of v. Also we can find v.rlen in a
similar manner. This completes our discussion of the length fields.</p>
<p>We still need to satisfy another requirement which is "given a chain
data structure, we must be able to retrieve the edges of the chain in
the constant time". It's very hard to retrieve the edges because the
data structure won't modify the corresponding structure of the left and
right subchains, so we don't know the sequence of a path as we are
getting them from mid to each side.</p>
<p>Our solution uses a compact representation of the differences between
the chain and its left and right subchains. To be more specific,
consider the node v that represents the chain before. Node v has two
lists associated with it, a left and a right <em>edge retrieval
list</em>. Each record r in a retrieval list has two pointers, one to a
node in the left/right subtree and one to a record in another retrieval
list, called the <em>partner</em> of r. So we define record as <span
class="math inline">\(record := (node pointer,partnerpointer)\)</span>.
The right retrieval list is analogous to the left retrieval list.</p>
<p>First we need to explain what's the node pointers. Let w be the left
child of v, and let u be the node in the subtree rooted at w whose edge
u.tan appears in <span class="math inline">\(\pi(A,E)\)</span> and is
incident to B. The records in v's left retrieval list point to the nodes
on the path from w to u, inclusive, whose associated edges belong to
<span class="math inline">\(\pi(A,E)\)</span>. The retrieval list keeps
the nodes in the same order as the path from w to u. This is the node
pointers of the left retrieval list and the right retrieval list are
defined analogously. I'll explain it in detail.</p>
<p>We will start with left retrieval list, from the figure we can get
the left retrieval list as [(w,-),(x,-),(u,-)].</p>
<figure>
<img data-src="Optimal-Shortest-Path-in-Simple-Polygon/leftretrieval.png"
alt="leftretrieval" />
<figcaption aria-hidden="true">leftretrieval</figcaption>
</figure>
<p>Also there's right retrieval list as[(w,-),(y,-),(u,-)].</p>
<figure>
<img data-src="Optimal-Shortest-Path-in-Simple-Polygon/rightretrival.png"
alt="rightretrival" />
<figcaption aria-hidden="true">rightretrival</figcaption>
</figure>
<p>Then there are some lemma shows some feature of retrieval lists, and
they will also enable us to specify the <em>partner</em> fields of list
records.</p>
<p><strong>Lemma 4</strong> Let s and t be two nodes pointed to by
consecutive records in the left retrieval list of v. Then these two
nodes are in an ancestor/descendant relationship. If s is the ancestor,
then t is in the right subtree of s, and some record in the right
retrieval list of s points to t. Analogous claims hold for records in
the right retrieval list of v.</p>
<p>Now we can specify the <em>partner</em> fields of retrieval list
records. Each record has its own field, the first record's field is
null. Let r and $r$ be two consecutive records in v's left retrieval
list that point to nodes s and t, and s is an ancestor of t. Then the
<em>partner</em> field of <span class="math inline">\(r\prime\)</span>
points to the record in the right retrieval list of s that points to t.
The partner fields of records in the right retrieval list are defined
analogously.</p>
<p>With the previous example we can update the two lists as: left
retrieval list[]</p>
<p>Then the following two lemmas show we can get the edges of a chain
with the edge retrieval lists in constant time apiece.</p>
<p><strong>Lemma5</strong> Let r be a record in the left retrieval list
of v, and let s be the node it points to. Using the part of the
retrieval list r heads, we can retrieve all the edges of v’s chain
strictly between s.tan and v.tan in left-to-right order and in constant
time per edge. A similar claim holds for right retrieval lists.</p>
<p><strong>Lemma6</strong> Using v’s left edge retrieval list, we can
report all the edges of v’s chain that are to the left of v. tan. We
produce the edges in left-to-right order and at constant cost per edge.
A similar claim holds for v’s right retrieval list.</p>
<p>Using the retrieval list we can get the edges of a chain in constant
time apiece. Also we found the list of a node v is bounded by the height
of v, and we will show there's another way to get the retrieval list
efficiently.</p>
<p>Let u be the node in v’s left subtree such that u.tan is adjacent to
v.tan in v’s chain. The left retrieval list of v points to nodes on the
path from v to u. To construct the retrieval list, we must be able to
tell which nodes on the path have edges in v’s chain. Our approach is
based on comparing pairs of diagonals or polygon edges using the hiding
test described below: Let t be a node in the tree rooted at v. If t.tan
does not appear in v's chain, there's some edge <span
class="math inline">\(\overline{ab}\)</span> in v's chain such that
t.tan is contained in the pocket defined by <span
class="math inline">\(\overline{ab}\)</span> and the polygon boundary
between a and b. We say that <span
class="math inline">\(\overline{ab}\)</span> hides t.tan.</p>
<figure>
<img
src="Optimal-Shortest-Path-in-Simple-Polygon/image-2023110453746869%20PM.png"
alt="image-2023110453746869 PM" />
<figcaption aria-hidden="true">image-2023110453746869 PM</figcaption>
</figure>
<p>We can test whether one edge hides another by comparing the indices
of their endpoints, assuming all the endpoints are polygon
vertices.Suppose that the edge connecting vertices i and l belongs to
v’s chain, and i is left of l on the chain.</p>
<ul>
<li>If i &lt; l, the polygon vertices are numbered consecutively along
the boundary of the pocket cut off by <span
class="math inline">\(\overline{il}\)</span>. In this case, an edge
<span class="math inline">\(\overline{jk}\)</span> is hidden by <span
class="math inline">\(\overline{il}\)</span> if and only if <span
class="math inline">\(\overline{jk} \neq \overline{il}\)</span> and both
integers j and k lie in the interval [i,l].</li>
<li>If i &gt; l, an edge <span
class="math inline">\(\overline{jk}\)</span> is hidden by <span
class="math inline">\(\overline{il}\)</span> if and only if <span
class="math inline">\(\overline{jk} \neq \overline{il}\)</span> and both
j and k are outside the interval [l+1,i-1].</li>
</ul>
<p>However, when we are doing query, not all chain vertics are polygon
vertices, some times query points p and q appear in some chains and they
are not polygon vertices, so we must assign them vertex numbers before
using the hiding test. Suppose that source point p lies in triangle $ $
and that <span class="math inline">\(d_p\)</span> is diagonsl <span
class="math inline">\(\overline{ik}\)</span>.</p>
<figure>
<img
src="Optimal-Shortest-Path-in-Simple-Polygon/image-2023110540530804%20PM.png"
alt="image-2023110540530804 PM" />
<figcaption aria-hidden="true">image-2023110540530804 PM</figcaption>
</figure>
<p>We constract the hourglass from p to q by pretending p is a polygon
vertex, we assign to p the vertex number j. Then it gives a consistent
counterclockwise numbering to the vertices of the unshaded subpolygon
and allow us to test hiding as described above.</p>
<p>The following lemma shows how to use the hiding test to construct
retrieval lists.</p>
<p>Lemma 7. Let u be the node in the left subtree of v such that u. tan
is adjacent to v. tan in v’s chain, and let t be a descendant of v on
the path from v to u. Let s be the lowest proper ancestor of t such that
s. tan appears in v’s chain. Either t. tan is hidden by s. tan or by v.
tan, or it appears in v’s chain.</p>
<p>Using this lemma to determine which nodes on the path from v to u
have edges in v's chain, we can go from v to u and test each one.
Suppose t is the current node and s is its lowest proper ancestor such
that s.tan appears in v's chain. If t.tan is not hidden by s.tan or
v.tan, then it appears in v's chain.</p>
<p>Until now we have all the elements of the chain data structure:</p>
<ol type="1">
<li>A chain is represented by the root node of a binary tree.</li>
<li>Each node has two edge retrieval lists to help report the edges of
the chain. With retrieval lists, each node uses storage proportional to
the height of the tree.</li>
<li>We can construct a chain's tree from its subchain's trees in time
proportional to the height of the new tree, which is proportional to the
sum of the heights of the subtrees.</li>
<li>The new chain's data structure does not modify any of the old
chain's data structures.</li>
</ol>
<p>With these facts, we can establish the following analogue
requirements:</p>
<p>(C2) If tangents from a point to chains <span
class="math inline">\(\pi(A, B)\)</span> and <span
class="math inline">\(\pi(B, C)\)</span> can be found in times t1 and
t2, the data structure for the combined chain <span
class="math inline">\(\pi(A, C)\)</span> can be built in O(t1 + t2) time
and additional space. Furthermore, the data structures for the original
two chains are unaltered by the construction.</p>
<p>(C4) The length of a chain can be found in constant time. The edge
sequence of the chain can be extracted in constant time per edge.</p>
<h4 id="string-data-structure">String data structure</h4>
<p>This subsection uses the chains of the preceding subsection to
implement the hourglass data structure. As the hourglass data structure
satisfies the requirements enunciated at the beginning of this section,
it can be used to answer shortest-path queries efficiently. The
hourglass data structure contains two main components chains and
strings. In the preceding subsection we described the chain data
structure, and this subsection we begin with a discussion of
strings.</p>
<p>If we were concerned only with the lengths of shortest paths and not
with the paths themselves, we could represent strings by their lengths
alone. However, we need additional structures to represent the edges of
a string. As there are two types of strings, fundamental and derived, we
need two types of representation. Fundamental strings are formed when
the concatenation of two hourglasses collapses the multiple paths
represented by funnels or open hourglasses into a single path. The
following figure are some examples of fundamental strings.</p>
<figure>
<img
src="Optimal-Shortest-Path-in-Simple-Polygon/image-2023110564024921%20PM.png"
alt="image-2023110564024921 PM" />
<figcaption aria-hidden="true">image-2023110564024921 PM</figcaption>
</figure>
<p>A derived string is produced when a choled hourglass is concatenated
with another hourglass. The following figure is an example of derived
string.</p>
<figure>
<img data-src="Optimal-Shortest-Path-in-Simple-Polygon/derived%20example.png"
alt="derived example" />
<figcaption aria-hidden="true">derived example</figcaption>
</figure>
<p>The chains that appear in strings are obtained by truncating
hourglass chains. We can represent truncated chains using the previous
data structure. To clip off the right end of a chain, we simply create a
new chain in which the old chain is the left subchain, the right
subchain is null, and the tangent edge is the new chain's right
endpoint. As discussed before, we cannot put one null edge next to
another, so any chain has at most one more null edge than it has
non-null edges.</p>
<p>From the definition we know a derived string when fully expanded is a
sequence of fundamental strings. The data structure for a derived string
is represented by an internal node whose children are its constituent
strings. The tree has two or three children per node. We construct the
derived string trees so that the non-empty fundamental strings that make
up a derived string can be extracted in constant time. When
concatenation would cause us to include an empty string in a derived
string, we drop that string. We also rule out nodes in the tree
representation of derived strings that have only one child.</p>
<p>So, when two hourglasses are concatenated and the resulting string is
just the string belonging to one of the two, we set the new hourglass to
point to the old string, rather than creating a new derived string node
with only one child. This strategy means that the internal nodes of a
derived string tree have at least two children.</p>
<p>Traversing the tree takes time proportional to the number of leaves
which is non-empty fundamental strings. Since the edges of each
fundamental string can be extracted in constant time per edge, the edges
of any string can be extracted within thesame time bound. This concludes
our discussion of the string data structure.</p>
<h4 id="hourglass-data-structure-implementation">hourglass data
structure: Implementation</h4>
<p>With these given data structure we can build our hourglass now. An
hourglass is built of at most four convex chains and one string. The
hourglass data structure has pointers to these live components. If any
of the parts is missing, as when the hourglass is open, the
corresponding pointer is null. To concatenate two hourglasses, we find
the relevant common tangents of their chains, build the appropriate
chains and strings, and set the pointer fields of a new hourglass
structure. Each new chain is either an old chain or a convex hull of two
old chains, possibly with an end clipped off as described above. The new
string, if any, is either a fundamental string or a derived string that
points to one new fundamental string and one or two old strings.</p>
<p>We can conclude from the preceding discussion that the hourglass data
structure meets its specification. Each hourglass and string record uses
a constant number of chains, and each concatenation requires a constant
number of chain operations. Because chains satisfy conditions (Cl)-(C4),
the hourglasses built from them satisfy requirements (l)-(4).</p>
<h3 id="improved-query-time-bounds">5. Improved Query Time bounds</h3>
<p>From discussion above we can do shortest path queries in <span
class="math inline">\(O(log^2 n)\)</span> time bound. This section shos
how to reduce that to O(log n) time.</p>
<p>We can observe that if many shortest path queries are answered,
hourglasses corresponding to edges high up in the factor graph are used
many times; furthermore, the cost of concatenating them is the major
contribution to query time. If we could find a way to bypass most of the
computation high up in <span class="math inline">\(S^*\)</span> then we
can reduce the query cost.</p>
<p>To find the shortest path from p to q there are four main steps:</p>
<ol type="1">
<li>Locate the points in the triangulation</li>
<li>find the subsequences <span class="math inline">\(D_p\)</span> and
<span class="math inline">\(D_q\)</span> of the separating
diagonals</li>
<li>find the hourglass between <span class="math inline">\(d_p\)</span>
and <span class="math inline">\(d_q\)</span></li>
<li>Concatenate <span class="math inline">\(H(p,d_P)\)</span> and <span
class="math inline">\(H(d_q,q)\)</span> with <span
class="math inline">\(H(d_p,d_q)\)</span>.</li>
</ol>
<p>In these steps only step 3 takes more than logarithmic time. To speed
up step 3 we can precompute some intermediate results it uses. As the
decomposition tree S is balanced, there are only <span
class="math inline">\(O(n/log^2n)\)</span> nodes in S with at least
$alog^2n $ descendants. Here a is a parameter that can be adjusted to
increase the amont of preprocessing to decrease the query time. Let the
set of these upper nodes to be U and then modify the factor graph <span
class="math inline">\(S^*\)</span> by adding some edges which connects U
with their ancestors. Each node of U has O((log n) ancestors, so the
modification adds O(n/log n)edges to <span
class="math inline">\(S^*\)</span>.</p>
<p>The hourglasses corresponding to the additional edges can be computed
in O(log n) time apiece as the data structures representing them have
log height.(Each node d in U must be linked to all its ancestors in S.
Linking to the ancestors in order along the path from d to the root of S
gives the claimed bounds.)And overall the additional hourglasses take
linear time and space to construct.</p>
<p>These additional hourglasses provide the necessary bypass sructures
to make <span class="math inline">\(O(log^2 n)\)</span> into O(log n)
time. Let p and q be the query points. In log time we can find the
subsequences <span class="math inline">\(D_p\)</span> and <span
class="math inline">\(D_q\)</span> of the separating diagonals. The
diagonal <span class="math inline">\(\hat d\)</span> is the lowest
common ancestor in S of <span class="math inline">\(d_p\)</span> and
<span class="math inline">\(d_q\)</span>. If <span
class="math inline">\(\hat d\)</span> is not in U, then the cells
between <span class="math inline">\(d_p\)</span> and <span
class="math inline">\(d_q\)</span> have <span
class="math inline">\(O(log^2 n)\)</span> edges altogether as they are
contained in <span class="math inline">\(P_{\hat d}\)</span>. There are
only <span class="math inline">\(O(log(log^2 n))\)</span> hourglasses
need to be concatenated in order to produce <span
class="math inline">\(H(d_p,d_q)\)</span>, and each concatenation takes
O(loglogn) time, so step 3 takes <span class="math inline">\(O((loglog
n)^2)\)</span> time, which is dominated by the time of the other
steps.</p>
<p>If <span class="math inline">\(\hat d\)</span> is in U let <span
class="math inline">\(d_p^-\)</span> be the highest diagonal in D that
is not in U, and let <span class="math inline">\(d_p^+\)</span> be the
next higher diagonal in <span class="math inline">\(D_p\)</span> (the
successor of <span class="math inline">\(d_p^-\)</span> in <span
class="math inline">\(D_p\)</span>). Define <span
class="math inline">\(d_q^-\)</span> and <span
class="math inline">\(d_q^+\)</span> similarly as the following figure
shows.</p>
<figure>
<img
src="Optimal-Shortest-Path-in-Simple-Polygon/image-20231107115052760%20PM.png"
alt="image-20231107115052760 PM" />
<figcaption aria-hidden="true">image-20231107115052760 PM</figcaption>
</figure>
<p>As discussed before, when <span class="math inline">\(\hat d \notin
U\)</span> we can find <span class="math inline">\(H(d_p,d_p^-)\)</span>
and <span class="math inline">\(H(d_q^-,d_q)\)</span> in <span
class="math inline">\(O((loglogn)^2)\)</span> time. The hourglasses
<span class="math inline">\(H(d_p^-,d_p^+)\)</span> and <span
class="math inline">\(H(d_q^-,d_q^+)\)</span> correspond to edges of
<span class="math inline">\(S^*\)</span> and been precomputed. Since
<span class="math inline">\(\hat d\)</span> is an ancestor in S of <span
class="math inline">\(d_p^+\)</span> and <span
class="math inline">\(d_q^+\)</span>, and all three diagonals are in U,
so the hourglasses <span class="math inline">\(H(d_P^+,\hat d)\)</span>
and <span class="math inline">\(H(\hat d,d_q^+\)</span>)also already
exist, so we can just concate these six hourglasses and get <span
class="math inline">\(H(d_p,d_q)\)</span> in logarithmic time, so the
length from p to q can be found in O(log n) time.</p>
<p>We have the final theorem as follows:</p>
<p>THEOREM 1. There is a linear space data structure for storing a
simple polygon P of size n so that given any two points inside P, the
length of the shortest path joining them can be computed in O(log n)
time. The actual path can be extracted in additional time proportional
to the number of turns along it. Furthermore, this shortest path query
structure for P can be computed in linear time once a triangulation of P
is available.</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Xuanlang
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/" title="Optimal-Shortest-Path-in-Simple-Polygon">https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/ShortestPath/" rel="tag"># ShortestPath</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/11/24/node-study/" rel="prev" title="node-study">
                  <i class="fa fa-chevron-left"></i> node-study
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="SOHUCS" sid="b56506efd8271fdd5039bf3fe9f8434f"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">津ICP备19008018号-1 </a>
  </div>

<div class="copyright">
  &copy; 2019 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-award"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xuanlang</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","single_dollars":true,"cjk_width":0.9,"normal_width":0.6,"append_css":true,"every_page":true,"js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://www.zhaoxuanlang.cn/2023/12/02/Optimal-Shortest-Path-in-Simple-Polygon/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="changyan" type="application/json">{"enable":true,"appid":"cyvRiUJ7H","appkey":"bfa85e46b2e4cf46d837cbd6e78ba7ab"}</script>
<script src="/js/third-party/comments/changyan.js"></script>

</body>
</html>
